import{_ as i,c as a,o as l,b1 as n}from"./chunks/framework.CBNrOPsJ.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"documents/interview/javascript.md","filePath":"documents/interview/javascript.md","lastUpdated":1749199251000}'),e={name:"documents/interview/javascript.md"};function t(h,s,k,p,r,o){return l(),a("div",null,s[0]||(s[0]=[n(`<h2 id="简单介绍下-promise" tabindex="-1">简单介绍下 Promise <a class="header-anchor" href="#简单介绍下-promise" aria-label="Permalink to &quot;简单介绍下 Promise&quot;">​</a></h2><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><ul><li><strong>用途</strong>：用来处理异步操作</li></ul><h3 id="三种状态" tabindex="-1">三种状态 <a class="header-anchor" href="#三种状态" aria-label="Permalink to &quot;三种状态&quot;">​</a></h3><ul><li><code>pending</code>：待定状态（初始状态）</li><li><code>fulfilled</code>：已完成状态（成功）</li><li><code>rejected</code>：已拒绝状态（失败）</li></ul><h3 id="参数和方法" tabindex="-1">参数和方法 <a class="header-anchor" href="#参数和方法" aria-label="Permalink to &quot;参数和方法&quot;">​</a></h3><ul><li><strong>构造函数参数</strong>：接受一个函数作为参数 <ul><li>该函数有两个参数：<code>resolve</code> 和 <code>reject</code></li><li><code>resolve</code>：用来处理异步操作成功的情况</li><li><code>reject</code>：用来处理异步操作失败的情况</li></ul></li></ul><h3 id="状态转换和处理" tabindex="-1">状态转换和处理 <a class="header-anchor" href="#状态转换和处理" aria-label="Permalink to &quot;状态转换和处理&quot;">​</a></h3><ul><li><strong>成功执行</strong>：执行 <code>resolve</code> → 状态从 <code>pending</code> 变为 <code>fulfilled</code> → 走 <code>then</code> 方法</li><li><strong>失败执行</strong>：执行 <code>reject</code> → 状态变为 <code>rejected</code> → 走 <code>catch</code> 方法</li><li><strong>最终执行</strong>：无论执行 <code>resolve</code> 还是 <code>reject</code>，都会走 <code>finally</code> 方法</li></ul><h3 id="解决的问题" tabindex="-1">解决的问题 <a class="header-anchor" href="#解决的问题" aria-label="Permalink to &quot;解决的问题&quot;">​</a></h3><ul><li>可以解决回调地狱问题</li></ul><h2 id="简单介绍下-async-await-并说下原理" tabindex="-1">简单介绍下 async/await 并说下原理 <a class="header-anchor" href="#简单介绍下-async-await-并说下原理" aria-label="Permalink to &quot;简单介绍下 async/await 并说下原理&quot;">​</a></h2><h3 id="基本概念-1" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念-1" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><ul><li><strong>async</strong>：用来声明一个异步函数 <ul><li>返回值是一个 Promise，无论内部是否有 await</li></ul></li><li><strong>await</strong>：用来等待一个 Promise 完成 <ul><li>如果 Promise 成功，await 返回 resolve 值</li><li>如果 Promise 失败，await 抛出错误，可以通过 <code>try…catch</code> 捕获</li></ul></li></ul><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><ul><li><strong>本质</strong>：generator 和 promise 的结合</li></ul><h4 id="generator-相关" tabindex="-1">Generator 相关 <a class="header-anchor" href="#generator-相关" aria-label="Permalink to &quot;Generator 相关&quot;">​</a></h4><ul><li><strong>定义</strong>：generator 是一个生成器，使用 <code>function*</code> 来定义</li><li><strong>执行机制</strong>：通过 <code>yield</code> 暂停函数执行，并返回一个迭代器对象</li><li><strong>恢复执行</strong>：通过迭代器对象的 <code>next</code> 方法恢复执行</li></ul><h4 id="对比差异" tabindex="-1">对比差异 <a class="header-anchor" href="#对比差异" aria-label="Permalink to &quot;对比差异&quot;">​</a></h4><ul><li><strong>yield vs await</strong>：yield 类似 await，但有以下不同： <ul><li>generator 返回的是一个迭代器对象</li><li>async 函数返回的是一个 Promise</li><li>async/await 会自动处理异步操作的结果</li><li>generator 则需要手动调用 next 方法</li></ul></li></ul><h3 id="相比-promise-的优势" tabindex="-1">相比 Promise 的优势 <a class="header-anchor" href="#相比-promise-的优势" aria-label="Permalink to &quot;相比 Promise 的优势&quot;">​</a></h3><ol><li><strong>代码可读性</strong>：避免链式调用，使异步代码看起来更像是同步的</li><li><strong>错误处理</strong>：使用 <code>try…catch</code> 捕获错误，比 <code>.catch</code> 更直观</li></ol><h3 id="扩展知识" tabindex="-1">扩展知识 <a class="header-anchor" href="#扩展知识" aria-label="Permalink to &quot;扩展知识&quot;">​</a></h3><p><strong>迭代器（iterator）和生成器（generator）的区别</strong>：</p><ul><li><strong>迭代器</strong>：是一个对象，需要手动实现 next 方法</li><li><strong>生成器</strong>：是一个函数，通过 yield 自动实现 next 方法</li><li><strong>关系</strong>：生成器是迭代器的超集</li></ul><h2 id="作用域、作用域链、闭包以及实际应用场景" tabindex="-1">作用域、作用域链、闭包以及实际应用场景 <a class="header-anchor" href="#作用域、作用域链、闭包以及实际应用场景" aria-label="Permalink to &quot;作用域、作用域链、闭包以及实际应用场景&quot;">​</a></h2><p><strong>作用域</strong>：函数和变量的可访问范围，分为全局作用域和局部作用域（函数作用域和块级作用域）</p><p><strong>作用域链</strong>：作用域链是 JavaScript 查找变量的一种机制。当访问一个变量时，JavaScript 会先在当前作用域查找，如果找不到，会逐级向上查找，直到全局作用域。这个查找路径就是作用域链。</p><p><strong>闭包</strong>：闭包是指函数能够访问其词法作用域中的变量，即使函数在其作用域外执行。</p><p><strong>闭包实际应用场景</strong>：</p><ul><li>数据封装和私有变量</li><li>函数柯里化（多参数函数转化为一系列但参数函数）</li><li>事件处理（button.addEventListener）</li><li>延迟执行（函数里有一个 settimeout，settimeout 中访问了函数参数）</li><li>防抖和节流（防抖通过在内部定义一个 timer，然后 return 一个函数，函数内部先清空上一个 timer，然后再给 timer 重新赋值）</li></ul><h2 id="简单介绍下事件循环" tabindex="-1">简单介绍下事件循环 <a class="header-anchor" href="#简单介绍下事件循环" aria-label="Permalink to &quot;简单介绍下事件循环&quot;">​</a></h2><p>首先，js 是单线程的，运行在浏览器的渲染主线程中。 当浏览器遇到事件处理、定时器、网络请求等操作时，为了不阻塞后续代码的执行，它会将这些异步操作放到一个消息队列中。 等到运行完同步的代码后，浏览器就会看看消息队列里还有没有要执行的任务。 同时，消息队列里的任务分为宏任务和微任务，微任务要比宏任务优先级高。 常见的宏任务有网络请求、定时器、requestAnimationFrame（浏览器中的动画帧回调），常见的微任务有 promise.then、await、MutationObserver（DOM 变化的观察者回调），vue 中数据批量更新以及 nexttick 也属于微任务</p><h2 id="如何减少-dom-操作来防止回流和重绘" tabindex="-1">如何减少 dom 操作来防止回流和重绘 <a class="header-anchor" href="#如何减少-dom-操作来防止回流和重绘" aria-label="Permalink to &quot;如何减少 dom 操作来防止回流和重绘&quot;">​</a></h2><ol><li>将逐个样式修改调整为一次性修改，或者直接添加一个 className</li><li>使用 css3 动画代替 js 动画</li><li>使用 flex 布局，相比传统或浮动布局，会少一些布局计算</li><li>减少元素层级嵌套</li><li>使用虚拟 dom（通过 diff 算法批量更新真实 dom）</li><li>使用 requestAnimationFrame 来合并动画帧更新</li></ol><h2 id="cookie、localstorage、sessionstorage-区别" tabindex="-1">cookie、localstorage、sessionstorage 区别 <a class="header-anchor" href="#cookie、localstorage、sessionstorage-区别" aria-label="Permalink to &quot;cookie、localstorage、sessionstorage 区别&quot;">​</a></h2><ol><li><p>存储大小： cookie：约 4KB。 localStorage 和 sessionStorage：约 5MB。</p></li><li><p>生命周期： cookie：可设置过期时间，手动清除或过期后失效。 localStorage：永久存储，除非手动清除。 sessionStorage：页面关闭后自动清除。</p></li><li><p>作用域： cookie：可设置路径和域名，同域名下共享。 localStorage：同域名下共享。 sessionStorage：仅当前页面有效，不共享。</p></li><li><p>与服务器的交互： cookie：每次请求自动携带在 HTTP 头部。 localStorage 和 sessionStorage：不参与服务器通信。</p></li><li><p>应用场景： cookie：存储登录状态、会话信息。 localStorage：长期存储数据，如用户偏好。 sessionStorage：临时存储数据，如表单数据。</p></li></ol><h2 id="通过-json-parse-json-stringfy-实现的深拷贝有什么缺点" tabindex="-1">通过 JSON.parse(JSON.stringfy()) 实现的深拷贝有什么缺点？ <a class="header-anchor" href="#通过-json-parse-json-stringfy-实现的深拷贝有什么缺点" aria-label="Permalink to &quot;通过 JSON.parse(JSON.stringfy()) 实现的深拷贝有什么缺点？&quot;">​</a></h2><ol><li><p>不支持函数： 函数属性会被忽略，拷贝后丢失。</p></li><li><p>不支持特殊对象： RegExp、Map、Set、Date 等对象会被转换为空对象或字符串，无法正确拷贝。</p></li><li><p>不支持循环引用： 如果对象存在循环引用（如 a 引用 b，b 又引用 a），会报错。</p></li><li><p>忽略 undefined 和 Symbol： undefined 和 Symbol 类型的属性会被忽略，拷贝后丢失。</p></li><li><p>性能问题： 对于大对象或复杂结构，JSON.stringify 和 JSON.parse 的性能较差。</p></li></ol><h2 id="如何让某个对象也能用-for-of" tabindex="-1">如何让某个对象也能用 for...of ? <a class="header-anchor" href="#如何让某个对象也能用-for-of" aria-label="Permalink to &quot;如何让某个对象也能用 for...of ?&quot;">​</a></h2><h3 id="方法-1-实现-symbol-iterator-方法" tabindex="-1">方法 1：实现 Symbol.iterator 方法 <a class="header-anchor" href="#方法-1-实现-symbol-iterator-方法" aria-label="Permalink to &quot;方法 1：实现 Symbol.iterator 方法&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 实现迭代器接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [Symbol.iterator]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> keys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keys.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keys[index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: [key, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[key]], done: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { done: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [key, value] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: &#39;a&#39; 1, &#39;b&#39; 2, &#39;c&#39; 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="方法-2-使用生成器函数-更简洁" tabindex="-1">方法 2：使用生成器函数（更简洁） <a class="header-anchor" href="#方法-2-使用生成器函数-更简洁" aria-label="Permalink to &quot;方法 2：使用生成器函数（更简洁）&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 使用生成器函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[Symbol.iterator]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasOwnProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Symbol.iterator) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [key, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[key]]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [key, value] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 1, 2, 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,44)]))}const g=i(e,[["render",t]]);export{E as __pageData,g as default};
