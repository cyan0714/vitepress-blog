import{_ as e,c as a,o as n,b1 as p}from"./chunks/framework.CBNrOPsJ.js";const t="/vitepress-blog/assets/1.Dou7-oy_.png",o="/vitepress-blog/assets/4.D0gXb5Al.png",i="/vitepress-blog/assets/5.DQ5a2YVp.png",l="/vitepress-blog/assets/6.CU8fX9ws.png",d="/vitepress-blog/assets/7.B6qCdqLV.png",c="/vitepress-blog/assets/8.DB2Rt_IX.png",m="/vitepress-blog/assets/9.BRTFWW72.png",r="/vitepress-blog/assets/10.v9Pa-6kK.png",h="/vitepress-blog/assets/2.BGGLpRbn.png",g="/vitepress-blog/assets/11.iAaMmqs9.png",q=JSON.parse('{"title":"pnpm","description":"","frontmatter":{},"headers":[],"relativePath":"documents/frontend/pnpm/pnpm.md","filePath":"documents/frontend/pnpm/pnpm.md","lastUpdated":1686292107000}'),u={name:"documents/frontend/pnpm/pnpm.md"};function k(b,s,_,x,y,v){return n(),a("div",null,s[0]||(s[0]=[p('<h1 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h1><h2 id="npm-的缺点" tabindex="-1">npm 的缺点 <a class="header-anchor" href="#npm-的缺点" aria-label="Permalink to &quot;npm 的缺点&quot;">​</a></h2><ol><li>在使用 <code>npm</code> 或 <code>yarn</code> 时，如果你有100个项目使用某个依赖项，那么你就会在磁盘上保存该依赖项的100个副本（比如这100个项目都使用了 <code>element-ui</code>, 那么磁盘上就会保存100份 element-ui 的源码）, 非常占用空间</li><li>使用 <code>npm</code> 或 <code>yarn</code> 安装依赖项时，所有的包都在 <code>node_modules</code> 的根目录。 这样就导致了一个问题，源码可以直接访问项目中依赖的依赖, 这样是不太好的（比如 <code>element-ui</code> 本身依赖 a 包, 表面上我们没有安装 a 包, 但却可以使用, 如果有一天删了 <code>element-ui</code>, 意味着 a 包也会删掉, 如果此时项目恰好引用了 a 包而忘记删除, 项目就会报错了） <img src="'+t+'" width="300px" style="padding-top:10px;"></li></ol><h2 id="什么是-pnpm" tabindex="-1">什么是 pnpm <a class="header-anchor" href="#什么是-pnpm" aria-label="Permalink to &quot;什么是 pnpm&quot;">​</a></h2><p><code>pnpm</code>是一种Node.js包管理器，它与<code>npm</code>类似，但具有更快的安装速度和更少的磁盘空间占用。与<code>npm</code>不同，<code>pnpm</code>使用<strong>软链接</strong>和<strong>硬链接</strong>来共享依赖项，这意味着每个依赖项只需要在磁盘上存储一次，而不是每个项目都存储一次。</p><h2 id="软链接和硬链接" tabindex="-1">软链接和硬链接 <a class="header-anchor" href="#软链接和硬链接" aria-label="Permalink to &quot;软链接和硬链接&quot;">​</a></h2><h3 id="_1-文件的本质" tabindex="-1">1. 文件的本质 <a class="header-anchor" href="#_1-文件的本质" aria-label="Permalink to &quot;1. 文件的本质&quot;">​</a></h3><p>在操作系统中，文件实际上是一个指针，只不过它指向的不是内存地址，而是一个外部存储地址（这里的外部存储可以是硬盘、U盘、甚至是网络） <img src="'+o+'" width="550px" style="padding-top:10px;"></p><p>当我们删除文件时，删除的实际上是指针，因此，无论删除多么大的文件，速度都非常快。像我们的U盘、硬盘里的文件虽然说看起来已经删除了，但是其实数据恢复公司是可以恢复的，因为数据还是存在的，只要删除文件后再没有存储其它文件就可以恢复，所以真正删除一个文件就是<strong>反复存反复删</strong></p><h3 id="_2-文件的拷贝" tabindex="-1">2. 文件的拷贝 <a class="header-anchor" href="#_2-文件的拷贝" aria-label="Permalink to &quot;2. 文件的拷贝&quot;">​</a></h3><p>如果你复制一个文件，是将该文件指针指向的内容进行复制，然后产生一个新文件指向新的内容。 <img src="'+i+'" width="550px" style="padding-top:10px;"></p><h3 id="_3-硬链接-hard-link" tabindex="-1">3. 硬链接 hard link <a class="header-anchor" href="#_3-硬链接-hard-link" aria-label="Permalink to &quot;3. 硬链接 hard link&quot;">​</a></h3><p>硬链接的概念来自于 Unix 操作系统，它是指将一个文件A指针复制到另一个文件B指针中，文件B就是文件A的硬链接。 <img src="'+l+'" width="550px" style="padding-top:10px;"> 通过硬链接，不会产生额外的磁盘占用，并且，两个文件都能找到相同的磁盘内容。 硬链接的数量没有限制，可以为同一个文件产生多个硬链接。</p><p>windows 可以在 cmd 中使用下面的命令可以创建硬链接。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mklink</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /h</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 链接名称</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 目标文件</span></span></code></pre></div><p>注意:</p><ol><li>由于文件夹（目录）不存在文件内容，所以文件夹（目录）不能创建硬链接</li><li>在 windows 操作系统中，通常不要跨越盘符创建硬链接</li></ol><h3 id="_4-软链接-symbol-link" tabindex="-1">4. 软链接 symbol link <a class="header-anchor" href="#_4-软链接-symbol-link" aria-label="Permalink to &quot;4. 软链接 symbol link&quot;">​</a></h3><p>软链接又称为符号链接，如果为某个文件或文件夹A创建符号连接B，则B指向A。 <img src="'+d+'" width="550px" style="padding-top:10px;"></p><p>windows 可以在 cmd 中使用下面的命令可以创建软链接。(软链接类似快捷方式)</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mklink</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 链接名称</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 目标文件</span></span></code></pre></div><p>由于符号链接指向的是另一个文件或目录，当执行该文件时，会使用原始路径。比方说：我在D盘装了LOL，在桌面创建了LOL快捷方式，相当于是符号链接，双击快捷方式运行游戏，在运行游戏的时候是按照LOL原始路径（D盘路径）运行的。</p><h3 id="_5-硬链接和软链接区别" tabindex="-1">5. 硬链接和软链接区别 <a class="header-anchor" href="#_5-硬链接和软链接区别" aria-label="Permalink to &quot;5. 硬链接和软链接区别&quot;">​</a></h3><ol><li>硬链接仅能链接文件，而符号链接可以链接目录</li><li>硬链接在链接完成后仅和文件内容关联，和之前链接的文件没有任何关系。而符号链接始终和之前链接的文件关联，和文件内容不直接相关。</li></ol><h2 id="pnpm-解决了哪些问题" tabindex="-1">pnpm 解决了哪些问题 <a class="header-anchor" href="#pnpm-解决了哪些问题" aria-label="Permalink to &quot;pnpm 解决了哪些问题&quot;">​</a></h2><ol><li>使用<code>pnpm</code>安装的包都会存储在硬盘上的某一位置。 当第三方包被安装时，包里的文件会<strong>硬链接</strong>到这一位置。 如果你有100个项目都使用了 element-ui, 那么磁盘上就会有100份 element-ui 硬链接到存储仓库中, 因为硬链接不会占用额外的磁盘空间, 所以可以解决包占用空间过大的问题。</li><li>如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有100个文件，而它的新版本只改变了其中1个文件。那么 <code>pnpm update</code> 时只会向存储中心额外添加1个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。</li></ol><h2 id="pnpm-原理" tabindex="-1">pnpm 原理 <a class="header-anchor" href="#pnpm-原理" aria-label="Permalink to &quot;pnpm 原理&quot;">​</a></h2><p>使用 pnpm 安装的包都存储到哪了呢? 在 pnpm 中，会将依赖安装到当前分区的 <code>&lt;home dir&gt;/.pnpm-store</code> 位置中，可以通过以下命令获得当前的 store 位置：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> store</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> path</span></span></code></pre></div><img src="'+c+'" width="400px" style="padding-top:10px;"><img src="'+m+`" width="550px" style="padding-top:10px;"><p><code>pnpm</code>利用硬链接将所需的包从<code>node_modules/.pnpm</code>硬链接到<code>store</code>中</p><p>通过软链接将<code>node_modules</code>中的顶层依赖以及依赖的依赖软链接到<code>node_modules/.pnpm</code>中</p><p>看如下例子:</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└─ .pnpm</span></span>
<span class="line"><span>   └─ demo-a@1.0.0</span></span>
<span class="line"><span>      └─ node_modules</span></span>
<span class="line"><span>         └─ demo-a -&gt; &lt;store&gt;/demo-a</span></span>
<span class="line"><span>   └─ demo-b@1.0.0</span></span>
<span class="line"><span>      └─ node_modules</span></span>
<span class="line"><span>         ├─ demo-a -&gt; ../../demo-a/node_modules/demo-a</span></span>
<span class="line"><span>         └─ demo-b -&gt; &lt;store&gt;/demo-b</span></span>
<span class="line"><span>   └─ demo-c@1.0.0</span></span>
<span class="line"><span>      └─ node_modules</span></span>
<span class="line"><span>         ├─ demo-a -&gt; ../../demo-a/node_modules/demo-a</span></span>
<span class="line"><span>         └─ demo-c -&gt; &lt;store&gt;/demo-c</span></span>
<span class="line"><span>└─ demo-b -&gt; ./.pnpm/demo-b@1.0.0/node_modules/demo-b</span></span>
<span class="line"><span>└─ demo-c -&gt; ./.pnpm/demo-c@1.0.0/node_modules/demo-c</span></span></code></pre></div><img src="`+r+'" width="700px" style="padding-top:10px;"><p>看如下例子: <img src="'+h+'" width="300px" style="padding-top:10px;"><img src="'+g+'" width="400px" style="padding-top:10px;"></p><p>上面例子只执行了 pnpm add element-ui, 但是因为 element-ui 也有其他依赖项, 所以会有除了 element-ui 以外的包, element-ui@2.15.13/node_modules 下的 element-ui 文件夹下的文件硬链接到存储仓库, 其他的文件夹通过软链接找到对应的包</p><h2 id="pnpm-的局限性" tabindex="-1">pnpm 的局限性 <a class="header-anchor" href="#pnpm-的局限性" aria-label="Permalink to &quot;pnpm 的局限性&quot;">​</a></h2><p>由于全局共用同一份 <code>store</code>，因此当需要修改 <code>node_modules</code> 内的内容时，会直接影响全局 <code>store</code> 中对应的内容，对其他项目也会造成影响</p>',40)]))}const f=e(u,[["render",k]]);export{q as __pageData,f as default};
