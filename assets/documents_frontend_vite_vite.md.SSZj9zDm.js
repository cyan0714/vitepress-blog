import{_ as s,c as a,o as e,b1 as t}from"./chunks/framework.CBNrOPsJ.js";const c=JSON.parse('{"title":"Vite","description":"","frontmatter":{},"headers":[],"relativePath":"documents/frontend/vite/vite.md","filePath":"documents/frontend/vite/vite.md","lastUpdated":1720229635000}'),l={name:"documents/frontend/vite/vite.md"};function p(n,i,r,h,o,k){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h1><h2 id="什么是构建工具" tabindex="-1">什么是构建工具 <a class="header-anchor" href="#什么是构建工具" aria-label="Permalink to &quot;什么是构建工具&quot;">​</a></h2><ol><li>typescript：浏览器不认识 ts，要使用 tsc 将 ts 代码转为 js 代码</li><li>react/vue：浏览器不认识 jsx 和 vue 文件，需要使用 react-compiler/vue-compiler 将其转为 render 函数</li><li>less/sass/postcss/component-style：需要安装 less-loader、sass-loader 等一系列编译工具</li><li>babel：将 es 新语法降级</li><li>uglifyjs：丑化代码</li></ol><p>有一个东西能够帮你把 tsc、react-compiler、less、babel、uglifyjs 全部集成在一起，这个东西就是 <strong>构建工具</strong></p><h2 id="构建工具承担了哪些脏活累活" tabindex="-1">构建工具承担了哪些脏活累活 <a class="header-anchor" href="#构建工具承担了哪些脏活累活" aria-label="Permalink to &quot;构建工具承担了哪些脏活累活&quot;">​</a></h2><ol><li>支持模块化开发：支持直接从 node_modules 里引入代码 + 多种模块化支持</li><li>处理代码兼容性：比如 babel 语法降级，less、ts 语法转换（不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理）</li><li>打包：我们写的浏览器不认识的代码，交给构建工具进行编译处理的过程就叫做打包，打包完成后会给我们一个浏览器可以认识的文件</li><li>提高项目性能：压缩文件，代码分割</li><li>优化开发体验：构建工具会帮你自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后浏览器重新运行（整个过程叫做热更新）</li><li>开发服务器：解决跨域问题</li></ol><p><strong>构建工具让我们不用关心生产的代码，也不用关心代码如何在浏览器运行，只需要关注开发时怎么写的舒服就怎么写就好了</strong></p><h2 id="市面上主流的构建工具" tabindex="-1">市面上主流的构建工具 <a class="header-anchor" href="#市面上主流的构建工具" aria-label="Permalink to &quot;市面上主流的构建工具&quot;">​</a></h2><p>webpack</p><p>vite</p><p>parcel</p><p>esbuild</p><p>rollup</p><p>grunt</p><p>gulp</p><h2 id="vite-相较于-webpack-的优势" tabindex="-1">vite 相较于 webpack 的优势 <a class="header-anchor" href="#vite-相较于-webpack-的优势" aria-label="Permalink to &quot;vite 相较于 webpack 的优势&quot;">​</a></h2><p>vite 官网中的一句话：</p><p>然而，随着我们构建的应用程序越来越多，我们要处理的JavaScript数量也在急剧增加。包含数千个模块的大型项目并不罕见。我们开始遇到基于JavaScript的工具的<strong>性能瓶颈</strong>:启动开发服务器通常需要不合理的长时间等待(<strong>有时长达几分钟</strong>!)，即使使用热模块替换(Hot Module Replacement, HMR)，文件编辑也需要几秒钟才能在浏览器中反映出来。缓慢的反馈循环会极大地影响开发人员的工作效率和幸福感。（<strong>webpack 的缺点</strong>）</p><p>webpack 有自己的一套代码转换规则：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lodash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lodash&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以上代码会被 webpack 通过 AST 分析出你写的 js 文件有哪些导入和导出操作，然后编译成：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lodash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> webpack_require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lodash&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Vue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> webpack_require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>因为 webpack 支持多种模块化，他一开始必须要统一模块化开发，所以意味着他需要将所有的依赖全部读一遍，当项目越大，需要读取的文件就越多，需要转化的文件就越多，启动时间就越长。</p><p>vite 会不会直接把 webpack 干翻？（两者侧重点不一样，webpack 更关注兼容性，vite 关注浏览器端的开发体验）</p><p>vite 是基于 es modules 的（目前大部分浏览器已经支持 es modules），他不需要将所有的依赖读一遍，意味着启动会非常快</p><h2 id="vite-脚手架和-vite-的区别" tabindex="-1">vite 脚手架和 vite 的区别 <a class="header-anchor" href="#vite-脚手架和-vite-的区别" aria-label="Permalink to &quot;vite 脚手架和 vite 的区别&quot;">​</a></h2><p>vite 官网中通过 <code>npm create vite@latest</code> 安装的是一个全局的包：create-vite（vite 的脚手架） 直接运行这个 create-vite bin 目录下的一个配置</p><p>create-vite 和 vite 的关系：create-vite 内置了 vite（相当于 vue-cli 内置了 webpack）</p><h2 id="vite-初体验" tabindex="-1">vite 初体验 <a class="header-anchor" href="#vite-初体验" aria-label="Permalink to &quot;vite 初体验&quot;">​</a></h2><p>开箱即用，不需要任何配置</p><p>默认情况下，esmodule 导入资源时要么是相对，要么是绝对路径</p><p>为什么浏览器不支持从 node_modules 里导入第三方包？因为会产生大量的网络请求，消耗性能</p><h2 id="使用-vite-初始化-vue3-项目" tabindex="-1">使用 vite 初始化 vue3 项目 <a class="header-anchor" href="#使用-vite-初始化-vue3-项目" aria-label="Permalink to &quot;使用 vite 初始化 vue3 项目&quot;">​</a></h2><p>npm init vite@latest</p><p>npm init vue@latest</p><h2 id="如何解决已经安装了某个第三方包-比如-axios-但还爆红问题" tabindex="-1">如何解决已经安装了某个第三方包，比如 axios，但还爆红问题？ <a class="header-anchor" href="#如何解决已经安装了某个第三方包-比如-axios-但还爆红问题" aria-label="Permalink to &quot;如何解决已经安装了某个第三方包，比如 axios，但还爆红问题？&quot;">​</a></h2><p>在 tsconfig.json 中的 compilerOptions 属性添加 &quot;moduleResolution&quot;: &quot;node”</p>`,35)]))}const v=s(l,[["render",p]]);export{c as __pageData,v as default};
