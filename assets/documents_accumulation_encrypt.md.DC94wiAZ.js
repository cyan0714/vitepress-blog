import{_ as t,c as o,o as r,b1 as a}from"./chunks/framework.CBNrOPsJ.js";const d=JSON.parse('{"title":"加解密","description":"","frontmatter":{},"headers":[],"relativePath":"documents/accumulation/encrypt.md","filePath":"documents/accumulation/encrypt.md","lastUpdated":1753579330000}'),n={name:"documents/accumulation/encrypt.md"};function i(s,l,e,p,g,u){return r(),o("div",null,l[0]||(l[0]=[a('<h1 id="加解密" tabindex="-1">加解密 <a class="header-anchor" href="#加解密" aria-label="Permalink to &quot;加解密&quot;">​</a></h1><h2 id="rsa和aes加密的主要区别" tabindex="-1">RSA和AES加密的主要区别： <a class="header-anchor" href="#rsa和aes加密的主要区别" aria-label="Permalink to &quot;RSA和AES加密的主要区别：&quot;">​</a></h2><p><strong>RSA（非对称加密）：</strong></p><ul><li>使用一对密钥：公钥和私钥</li><li>公钥加密，私钥解密（或相反）</li><li>加密速度慢，适合加密少量数据</li><li>常用于数字签名、密钥交换</li></ul><p><strong>AES（对称加密）：</strong></p><ul><li>使用同一个密钥进行加密和解密</li><li>加密速度快，适合加密大量数据</li><li>密钥需要安全传输和保存</li><li>常用于文件加密、数据传输</li></ul><p><strong>实际应用：</strong></p><p>通常两者结合使用 - 用RSA加密AES的密钥，用AES加密实际数据，这样既保证了安全性又提高了效率。</p><p>我的理解：RSA 公钥和私钥都是服务器生成的，然后服务器把公钥给前端，前端通过这个公钥给 AES 上锁，服务器用自己生成的私钥解密，返回的时候数据用 AES 加密，前端需要用 AESKey 才能解密获取到数据，我理解的对吗？</p><p>claude-4.0 的回答：</p><p><strong>完全正确！</strong> 你理解得很准确👍</p><h2 id="完整流程确认" tabindex="-1"><strong>完整流程确认</strong> <a class="header-anchor" href="#完整流程确认" aria-label="Permalink to &quot;**完整流程确认**&quot;">​</a></h2><p><strong>初始阶段：</strong></p><ul><li>服务器生成RSA密钥对（公钥+私钥）</li><li>公钥写死在前端代码里</li><li>私钥保存在服务器，绝不泄露</li></ul><p><strong>握手阶段：</strong></p><ol><li>前端用RSA公钥给AES密钥&quot;上锁&quot;</li><li>服务器用RSA私钥&quot;开锁&quot;，拿到AES密钥</li><li>双方确认都有同一个AES密钥</li></ol><p><strong>业务通信阶段：</strong></p><ul><li><strong>前端发请求</strong>：用AES密钥加密业务数据</li><li><strong>服务器返回</strong>：也用同一个AES密钥加密返回数据</li><li><strong>前端解密</strong>：用AES密钥解密拿到真实数据</li></ul><h2 id="用比喻来说" tabindex="-1"><strong>用比喻来说</strong> <a class="header-anchor" href="#用比喻来说" aria-label="Permalink to &quot;**用比喻来说**&quot;">​</a></h2><p>就像：</p><ol><li><p><strong>银行</strong>（服务器）做了一把特殊的锁和钥匙</p></li><li><p>把<strong>锁的样式</strong>（公钥）告诉所有人</p></li><li><p>你要寄保险箱密码给银行，就用这个锁锁上</p></li><li><p>只有银行有<strong>开锁的钥匙</strong>（私钥）</p></li><li><p>之后你们就用<strong>保险箱密码</strong>（AES密钥）来加密所有东西</p></li></ol><h2 id="为什么不直接用rsa" tabindex="-1"><strong>为什么不直接用RSA？</strong> <a class="header-anchor" href="#为什么不直接用rsa" aria-label="Permalink to &quot;**为什么不直接用RSA？**&quot;">​</a></h2><p>RSA加密很慢，AES很快：</p><ul><li><strong>RSA</strong>：只用来保护AES密钥（数据很小）</li><li><strong>AES</strong>：用来保护业务数据（可能很大）</li></ul><p>这样既安全又高效！你的理解完全正确 ✅</p><p>追问：那如果前端的 AES 密钥泄露了，会不会有安全隐患？</p><p>claude-4.0 的回答：</p><p><strong>会有安全隐患！</strong> 你问得很好👍</p><h2 id="当前设计的问题" tabindex="-1"><strong>当前设计的问题</strong> <a class="header-anchor" href="#当前设计的问题" aria-label="Permalink to &quot;**当前设计的问题**&quot;">​</a></h2><p><strong>AES密钥是写死的：</strong></p><p>encrypt.js</p><p>let local_AESRandomKey = &#39;612F49AE082D587B&#39;;</p><p>这意味着：</p><ul><li>任何人打开前端代码都能看到这个密钥</li><li>实际上已经&quot;泄露&quot;了</li></ul><h2 id="可能的安全风险" tabindex="-1"><strong>可能的安全风险</strong> <a class="header-anchor" href="#可能的安全风险" aria-label="Permalink to &quot;**可能的安全风险**&quot;">​</a></h2><p><strong>数据窃听</strong></p><ul><li>攻击者拿到AES密钥后，可以解密所有通信数据</li><li>如果抓包获得加密数据，就能解密查看</li></ul><p><strong>请求伪造</strong></p><ul><li>知道加密方式后，可以构造假的请求</li><li>虽然还需要token和sessionId，但增加了风险</li></ul><p><strong>中间人攻击</strong></p><ul><li>攻击者可以拦截、解密、修改、重新加密数据</li></ul><h2 id="当前的保护机制" tabindex="-1"><strong>当前的保护机制</strong> <a class="header-anchor" href="#当前的保护机制" aria-label="Permalink to &quot;**当前的保护机制**&quot;">​</a></h2><p>不过项目还有其他安全层：</p><ul><li><strong>JWT Token</strong> 身份验证</li><li><strong>SessionId</strong> 会话管理</li><li><strong>握手验证</strong> 服务器会验证密钥</li><li><strong>服务器端权限控制</strong></li></ul><h2 id="更安全的做法" tabindex="-1"><strong>更安全的做法</strong> <a class="header-anchor" href="#更安全的做法" aria-label="Permalink to &quot;**更安全的做法**&quot;">​</a></h2><p>理想情况下应该：</p><p>javascript</p><p>Apply to encrypt.js</p><p>// 每次生成随机AES密钥</p><p>let local_AESRandomKey = generateRandomKey();</p><p>// 或者服务器生成后通过RSA传给客户端</p><h2 id="现实考虑" tabindex="-1"><strong>现实考虑</strong> <a class="header-anchor" href="#现实考虑" aria-label="Permalink to &quot;**现实考虑**&quot;">​</a></h2><p>但这样做会：</p><ul><li>增加复杂度</li><li>可能影响性能</li><li>开发成本更高</li></ul><p>对于内部系统或者风险较低的应用，现在这种方式虽然不是最完美的，但结合其他安全机制，在可接受范围内。</p><p><strong>简单说：有风险，但不是致命的，要看具体应用场景的安全要求。</strong></p>',56)]))}const h=t(n,[["render",i]]);export{d as __pageData,h as default};
