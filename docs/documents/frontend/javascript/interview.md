# JS 面试题

## 1. 什么是跨域请求? 你可以通过哪些方法解决跨域问题?

跨域请求是指在浏览器中，当一个网页尝试加载来自不同域名下的资源时会发生跨域请求。浏览器的同源策略会阻止跨域请求，以保护用户的安全。跨域请求可以通过以下几种方法解决： 
1. JSONP (JSON with Padding)：通过动态创建 `<script>` 标签来实现跨域请求，但只支持GET请求。 
2. CORS (Cross-Origin Resource Sharing)：服务端设置响应头中的 Access-Control-Allow-Origin 字段来允许跨域请求。 
3. 代理服务器：在同源的服务器端发起请求，然后再将数据传递给客户端，绕过浏览器的同源策略。 
4. WebSocket：通过WebSocket协议进行跨域通信。

- 在使用 vue 开发项目过程中, 可以在 `vue.config.js` 的 `devServer` 中配置 `proxy`, 此时的代理称为正向代理; 
- 正式环境中可以在 nginx 中配置代理, 此时的代理称为反向代理(比如有一个前端服务, 跑在 5000 端口, 一个后端服务, 跑在 3000 端口, 此时前端请求后端服务会造成跨域, 为了解决这个问题, 可以在 nginx 中配置代理, 添加一个 8000 服务作为中转, 如果路径以 / 开头, 则代理到 5000 端口, 如果路径以 /api 开头, 则代理到 3000 端口. 此时浏览器的 network 中显示的 url 的端口为 8000, 但是实际请求的是 3000 端口, 这种客户端不知道服务端实际请求的是哪个地址就被称为"反向代理")

## 2. 有哪些方法可以优化网站？
1. **压缩和合并资源**： 
   - 压缩CSS、JavaScript和图片等静态资源，减小文件大小。 
   - 合并多个CSS和JavaScript文件，减少HTTP请求次数。 
 
2. **使用CDN（内容分发网络）**： 
   - 将静态资源部署到CDN上，加速资源加载速度，减轻服务器负担。 
 
3. **懒加载（Lazy Loading）**： 
   - 仅在用户需要时加载图片、视频或其他资源，减少首次加载时间（比如图片、路由懒加载）。 
 
4. **优化图片**： 
   - 使用适当的图片格式（如WebP）和大小，以减少图片加载时间。 
   - 使用CSS sprites或SVG图像来减少HTTP请求。 
 
5. **减少重定向和请求次数**： 
   - 减少重定向，确保页面引用的资源有效且减少不必要的请求。 
 
6. **缓存优化**： 
   - 利用浏览器缓存机制，设置合适的缓存头，减少重复加载。 
   - 使用服务端缓存（如HTTP缓存、Redis缓存等）来提高性能。 
 
7. **异步加载脚本**： 
   - 使用 async 或 defer 属性加载JavaScript，避免阻塞页面渲染。 
 
8. **减少DOM操作**： 
   - 减少DOM操作次数，合并操作，减少重排和重绘。 

## 3. 简单介绍下 Promise
promise 是用来处理异步操作的。
它有三种状态 pending、fullfilled、rejected。
它接受一个函数作为参数，这个函数有两个参数，分别为 resolve 和 reject。
resolve 用来处理异步操作成功的情况，reject 则用来处理失败的情况。
执行 resolve，状态就会从 pending 变到 fullfilled，然后走then方法。
执行 reject，状态就变成 rejected，然后走 catch方法。
无论执行 resolve 还是 reject ，都会走 finally 方法。可以解决回调地狱问题

## 4. 简单介绍下 async/await 并说下原理
async 用来声明一个异步函数，返回值是一个 promise，无论内部是否有 await；await 用来等待一个 promise 完成，如果 promise 成功，await 返回resolve 值，如果失败，await 则抛出错误，可以通过 try…catch 捕获

**原理：本质上是 generator 和 promise 的结合**
- generator 是一个生成器，使用 function* 来定义，通过 yield 暂停函数执行，并返回一个迭代器对象，再通过迭代器对象的 next 方法恢复执行。
- yield 类似 await，不同的地方在于 generator 返回的是一个迭代器对象，async 函数返回的是一个 promise；async/await 会自动处理异步操作的结果，generator 则需要手动调用 next 方法

**扩展**
- 对比 promise 优势
1. 避免链式调用，使异步代码看起来更像是同步的
2. 使用try…catch捕获错误，比.catch更直观

- 迭代器（iterator）和生成器（generator）的区别
迭代器是一个对象，需要手动实现 next 方法；生成器是一个函数，通过 yield 自动实现 next 方法，生成器是迭代器的超集

## 5. 作用域、作用域链、闭包以及实际应用场景
**作用域**：函数和变量的可访问范围，分为全局作用域和局部作用域（函数作用域和块级作用域）

**作用域链**：作用域链是 JavaScript 查找变量的一种机制。当访问一个变量时，JavaScript 会先在当前作用域查找，如果找不到，会逐级向上查找，直到全局作用域。这个查找路径就是作用域链。

**闭包**：闭包是指函数能够访问其词法作用域中的变量，即使函数在其作用域外执行。

**闭包实际应用场景**：
- 数据封装和私有变量
- 函数柯里化（多参数函数转化为一系列但参数函数）
- 事件处理（button.addEventListener）
- 延迟执行（函数里有一个settimeout，settimeout中访问了函数参数）
- 防抖和节流（防抖通过在内部定义一个timer，然后return一个函数，函数内部先清空上一个timer，然后再给timer重新赋值）

## 6. 简单介绍下事件循环
首先，js 是单线程的，运行在浏览器的渲染主线程中。
当浏览器遇到事件处理、定时器、网络请求等操作时，为了不阻塞后续代码的执行，它会将这些异步操作放到一个消息队列中。
等到运行完同步的代码后，浏览器就会看看消息队列里还有没有要执行的任务。
同时，消息队列里的任务分为宏任务和微任务，微任务要比宏任务优先级高。
常见的宏任务有网络请求、定时器、requestAnimationFrame（浏览器中的动画帧回调），常见的微任务有promise.then、await、MutationObserver（DOM 变化的观察者回调），vue 中数据批量更新以及 nexttick 也属于微任务

## 7. 如何减少dom操作来防止回流和重绘
1. 将逐个样式修改调整为一次性修改，或者直接添加一个className
2. 使用css3动画代替js动画
3. 使用flex布局，相比传统或浮动布局，会少一些布局计算
4. 减少元素层级嵌套
5. 使用虚拟dom（通过diff算法批量更新真实dom）
6. 使用requestAnimationFrame来合并动画帧更新
